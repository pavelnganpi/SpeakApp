{"_id":"readable-stream","_rev":"43-0a5fa964553d49f657de2056866ff2d9","name":"readable-stream","description":"An exploration of a new kind of readable streams for Node.js","dist-tags":{"latest":"1.1.9"},"versions":{"0.0.1":{"name":"readable-stream","version":"0.0.1","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nAn exploration of a new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\n## Usage\n\n```javascript\nvar Readable = require('readable-stream');\nvar r = new Readable();\n\nr.read = function(n) {\n  // your magic goes here.\n  // return n bytes, or null if there is nothing to be read.\n  // if you return null, then you MUST emit 'readable' at some\n  // point in the future if there are bytes available, or 'end'\n  // if you are not going to have any more data.\n  //\n  // You MUST NOT emit either 'end' or 'readable' before\n  // returning from this function, but you MAY emit 'end' or\n  // 'readable' in process.nextTick().\n};\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n```\n\n## Justification\n\nWritable streams in node are very straightforward to use and extend.\nThe `write` method either returns `true` if the bytes could be\ncompletely handled and another `write` should be performed, or `false`\nif you would like the user to back off a bit, in which case a `drain`\nevent at some point in the future will let them continue writing.  The\n`end()` method lets the user indicate that no more bytes will be\nwritten.  That's pretty much the entire required interface for\nwriting.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, and so on.  This is all\nrather brittle and easy to get wrong for all but the most trivial use\ncases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.\n\n### Compatibility\n\nIt's not particularly difficult to wrap older-style streams in this\nnew interface, or to wrap this type of stream in the older-style\ninterface.\n\nThe `Readable` class takes an argument which is an old-style stream\nwith `data` events and `pause()` and `resume()` methods, and uses that\nas the data source.  For example:\n\n```javascript\nvar r = new Readable(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n```\n\nThe `Readable` class will also automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n});\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n","_id":"readable-stream@0.0.1","dist":{"shasum":"f3efb2ca59b6e7c615f14a2e935ffdd042a46845","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.0.1.tgz"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"0.0.2":{"name":"readable-stream","version":"0.0.2","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nAn exploration of a new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\n## Usage\n\n```javascript\nvar Readable = require('readable-stream');\nvar r = new Readable();\n\nr.read = function(n) {\n  // your magic goes here.\n  // return n bytes, or null if there is nothing to be read.\n  // if you return null, then you MUST emit 'readable' at some\n  // point in the future if there are bytes available, or 'end'\n  // if you are not going to have any more data.\n  //\n  // You MUST NOT emit either 'end' or 'readable' before\n  // returning from this function, but you MAY emit 'end' or\n  // 'readable' in process.nextTick().\n};\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n```\n\n## Justification\n\nWritable streams in node are very straightforward to use and extend.\nThe `write` method either returns `true` if the bytes could be\ncompletely handled and another `write` should be performed, or `false`\nif you would like the user to back off a bit, in which case a `drain`\nevent at some point in the future will let them continue writing.  The\n`end()` method lets the user indicate that no more bytes will be\nwritten.  That's pretty much the entire required interface for\nwriting.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, and so on.  This is all\nrather brittle and easy to get wrong for all but the most trivial use\ncases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.\n\n### Compatibility\n\nIt's not particularly difficult to wrap older-style streams in this\nnew interface, or to wrap this type of stream in the older-style\ninterface.\n\nThe `Readable` class takes an argument which is an old-style stream\nwith `data` events and `pause()` and `resume()` methods, and uses that\nas the data source.  For example:\n\n```javascript\nvar r = new Readable(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n```\n\nThe `Readable` class will also automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n});\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n","_id":"readable-stream@0.0.2","dist":{"shasum":"cce59fac644aac782792573201ebb346b257717f","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.0.2.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"0.0.3":{"name":"readable-stream","version":"0.0.3","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nAn exploration of a new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\nNote that Duplex, Transform, Writable, and PassThrough streams are also\nprovided as base classes.  See the full API details below.\n\n## Justification\n\n<!-- misc -->\n\nWritable streams in node are relatively straightforward to use and\nextend.  The `write` method either returns `false` if you would like\nthe user to back off a bit, in which case a `drain` event at some\npoint in the future will let them continue writing, or anything other\nthan false if the bytes could be completely handled and another\n`write` should be performed, or   The `end()` method lets the user\nindicate that no more bytes will be written.  That's pretty much the\nentire required interface for writing.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n3. In many streams, `pause()` was purely advisory, so **even while\n   paused**, you still have to be careful that you might get some\n   data.  This caused a lot of subtle b ugs.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nAnd read consumers had to always be prepared for their backpressure\nadvice to simply be ignored.\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, slicing, and so on.  This\nis all rather brittle and easy to get wrong for all but the most\ntrivial use cases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\n<!-- misc -->\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.  Any data that\nwas already in the process of being read will be placed in a buffer.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.  The\nproblems of data events happening while paused are alleviated.\n\n### Compatibility\n\n<!-- misc -->\n\nIt's not particularly difficult to wrap older-style streams in this\nnew interface, or to wrap this type of stream in the older-style\ninterface.\n\nThe `Readable` class provides a `wrap(oldStream)` method that takes an\nargument which is an old-style stream with `data` events and `pause()`\nand `resume()` methods, and uses that as the data source.  For\nexample:\n\n```javascript\nvar r = new Readable();\nr.wrap(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n// but the data is based on whatever oldReadableStream spits out of\n// its 'data' events.\n```\n\nIn order to work with programs that use the older interface, some\nmagic is unfortunately required.  At some point in the future, this\nmagic will be removed.\n\nThe `Readable` class will automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n  // magic is happening!  oh no!  the animals are walking upright!\n  // the brooms are sweeping the floors all by themselves!\n});\n\n// this will also turn on magic-mode:\nr.pause();\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n\n## Class: Readable\n\nA base class for implementing Readable streams.  Override the\n`_read(n,cb)` method to fetch data asynchronously and take advantage\nof the buffering built into the Readable class.\n\n### Example\n\nExtend the Readable class, and provide a `_read(n,cb)` implementation\nmethod.\n\n```javascript\nvar Readable = require('readable-stream');\nvar util = require('util');\n\nutil.inherits(MyReadable, Readable);\n\nfunction MyReadable(options) {\n  Readable.call(this, options);\n}\n\nMyReadable.prototype._read = function(n, cb) {\n  // your magic goes here.\n  // call the cb at some time in the future with either up to n bytes,\n  // or an error, like cb(err, resultData)\n  //\n  // The code in the Readable class will call this to keep an internal\n  // buffer at a healthy level, as the user calls var chunk=stream.read(n)\n  // to consume chunks.\n};\n\nvar r = new MyReadable();\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n\n// to get some bytes out of it:\nvar data = r.read(optionalLengthArgument);\n// now data is either null, or a buffer of optionalLengthArgument\n// length.  If you don't provide an argument, then it returns whatever\n// it has.\n\n// typically you'd just r.pipe() into some writable stream, but you\n// can of course do stuff like this, as well:\nfunction flow() {\n  var chunk;\n  while (null !== (chunk = r.read())) {\n    doSomethingWithData(chunk);\n  }\n  r.once('readable', flow);\n}\nflow();\n```\n\n### new Readable(options)\n\n* `options` {Object}\n  * `lowWaterMark` {Number} The minimum number of bytes before the\n    stream is considered 'readable'.  Default = `1024`\n  * `bufferSize` {Number} The number of bytes to try to read from the\n    underlying `_read` function.  Default = `16 * 1024`\n\nMake sure to call the `Readable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### readable.read([n])\n\n* `n` {Number} Optional number of bytes to read.  If not provided,\n  then return however many bytes are available.\n* Returns: {Buffer | null}\n\nPulls the requested number of bytes out of the internal buffer.  If\nthat many bytes are not available, then it returns `null`.\n\n### readable.\\_read(n, callback)\n\n* `n` {Number} Number of bytes to read from the underlying\n  asynchronous data source.\n* `callback` {Function} Callback function\n  * `error` {Error Object}\n  * `data` {Buffer | null}\n\n**Note: This function is not implemented in the Readable base class.**\nRather, it is up to you to implement `_read` in your extension\nclasses.\n\n`_read` should fetch the specified number of bytes, and call the\nprovided callback with `cb(error, data)`, where `error` is any error\nencountered, and `data` is the returned data.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### readable.pipe(destination)\n\n* `destination` {Writable Stream object}\n\nContinually `read()` data out of the readable stream, and `write()` it\ninto the writable stream.  When the `writable.write(chunk)` call\nreturns `false`, then it will back off until the next `drain` event,\nto do backpressure.\n\nPiping to multiple destinations is supported.  The slowest destination\nstream will limit the speed of the `pipe()` flow.\n\nNote that this puts the readable stream into a state where not very\nmuch can be done with it.  You can no longer `read()` from the stream\nin other code, without upsetting the pipe() process.  However, since\nmultiple pipe destinations are supported, you can always create a\n`PassThrough` stream, and pipe the reader to that.  For example:\n\n```\nvar r = new ReadableWhatever();\nvar pt = new PassThrough();\n\nr.pipe(someWritableThing);\nr.pipe(pt);\n\n// now I can call pt.read() to my heart's content.\n// note that if I *don't* call pt.read(), then it'll back up and\n// prevent the pipe() from flowing!\n```\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream object} Optional\n\nRemove the provided `destination` stream from the pipe flow.  If no\nargument is provided, then it will unhook all piped destinations.\n\n### readable.on('readable')\n\nAn event that signals more data is now available to be read from the\nstream.  Emitted when more data arrives, after previously calling\n`read()` and getting a null result.\n\n### readable.on('end')\n\nAn event that signals that no more data will ever be available on this\nstream.  It's over.\n\n### readable.\\_readableState\n\n* {Object}\n\nAn object that tracks the state of the stream.  Buffer information,\nwhether or not it has reached the end of the underlying data source,\netc., are all tracked on this object.\n\nYou are strongly encouraged not to modify this in any way, but it is\noften useful to read from.\n\n## Class: Writable\n\nA base class for creating Writable streams.  Similar to Readable, you\ncan create child classes by overriding the asynchronous\n`_write(chunk,cb)` method, and it will take care of buffering,\nbackpressure, and so on.\n\n### new Writable(options)\n\n* `options` {Object}\n  * `highWaterMark` {Number} The number of bytes to store up before it\n    starts returning `false` from write() calls.  Default = `16 * 1024`\n  * `lowWaterMark` {Number} The number of bytes that the buffer must\n    get down to before it emits `drain`.  Default = `1024`\n\nMake sure to call the `Writable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### writable.write(chunk, [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String} An encoding argument to turn the string chunk\n  into a buffer.  Only relevant if `chunk` is a string.\n  Default = `'utf8'`.\n* Returns `false` if you should not write until the next `drain`\n  event, or some other value otherwise.\n\nThe basic write function.\n\n### writable.\\_write(chunk, callback)\n\n* `chunk` {Buffer}\n* `callback` {Function}\n  * `error` {Error | null} Call with an error object as the first\n    argument to indicate that the write() failed for unfixable\n    reasons.\n\n**Note: This function is not implemented in the Writable base class.**\nRather, it is up to you to implement `_write` in your extension\nclasses.\n\n`_write` should do whatever has to be done in this specific Writable\nclass, to handle the bytes being written.  Write to a file, send along\na socket, encrypt as an mp3, whatever needs to be done.  Do your I/O\nasynchronously, and call the callback when it's complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### writable.end([chunk], [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String}\n\nIf a chunk (and, optionally, an encoding) are provided, then that\nchunk is first passed to `this.write(chunk, encoding)`.\n\nThis method is a way to signal to the writable stream that you will\nnot be writing any more data.  It should be called exactly once for\nevery writable stream.\n\nCalling `write()` *after* calling `end()` will trigger an error.\n\n### writable.on('pipe', source)\n\nEmitted when calling `source.pipe(writable)`.  See above for the\ndescription of the `readable.pipe()` method.\n\n### writable.on('unpipe', source)\n\nEmitted when calling `source.unpipe(writable)`.  See above for the\ndescription of the `readable.unpipe()` method.\n\n### writable.on('drain')\n\nIf a call to `writable.write()` returns false, then at some point in\nthe future, this event will tell you to start writing again.\n\n### writable.on('finish')\n\nWhen the stream has been ended, and all the data in its internal\nbuffer has been consumed, then it emits a `finish` event to let you\nknow that it's completely done.\n\nThis is particularly handy if you want to know when it is safe to shut\ndown a socket or close a file descriptor.  At this time, the writable\nstream may be safely disposed.  Its mission in life has been\naccomplished.\n\n## Class: Duplex\n\nA base class for Duplex streams (ie, streams that are both readable\nand writable).\n\nSince JS doesn't have multiple prototypal inheritance, this class\nprototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n,cb)` method as well as the lowlevel `_write(chunk,cb)`\nmethod on extension duplex classes.\n\nFor cases where the written data is transformed into the output, it\nmay be simpler to use the `Transform` class instead.\n\n### new Duplex(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Duplex` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\nIf `options.allowHalfOpen` is set to the value `false`, then the\nstream will automatically end the readable side when the writable\nside ends, and vice versa.\n\n### duplex.allowHalfOpen\n\n* {Boolean} Default = `true`\n\nSet this flag to either `true` or `false` to determine whether or not\nto automatically close the writable side when the readable side ends,\nand vice versa.\n\n\n## Class: Transform\n\nA duplex (ie, both readable and writable) stream that is designed to\nmake it easy to implement transform operations such as encryption,\ndecryption, compression, and so on.\n\nTransform streams are `instanceof` Readable, but they have all of the\nmethods and properties of both Readable and Writable streams.  See\nabove for the list of events and methods that Transform inherits from\nWritable and Readable.\n\nOverride the `_transform(chunk, outputFunction, callback)` method in\nyour implementation classes to take advantage of it.\n\n### new Transform(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Transform` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### transform.\\_transform(chunk, outputFn, callback)\n\n* `chunk` {Buffer} The chunk to be transformed.\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_transform` in your extension\nclasses.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that this may mean that you call the `outputFn` zero\nor more times, depending on how much data you want to output as a\nresult of this chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(outputFn, callback)\n\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_flush` in your extension\nclasses optionally, if it applies to your use case.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `outputFn` zero or more times, as\nappropriate, and call `callback` when the flush operation is complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n## Class: PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n","readmeFilename":"README.md","_id":"readable-stream@0.0.3","dist":{"shasum":"f2fbbe635e3455bf1c7ea05c5e2ed8bf7eb8de62","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.0.3.tgz"},"_npmVersion":"1.1.63","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"0.0.4":{"name":"readable-stream","version":"0.0.4","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nA new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\nNote that Duplex, Transform, Writable, and PassThrough streams are also\nprovided as base classes.  See the full API details below.\n\n## Justification\n\n<!-- misc -->\n\nWritable streams in node are relatively straightforward to use and\nextend.  The `write` method either returns `false` if you would like\nthe user to back off a bit, in which case a `drain` event at some\npoint in the future will let them continue writing, or anything other\nthan false if the bytes could be completely handled and another\n`write` should be performed, or   The `end()` method lets the user\nindicate that no more bytes will be written.  That's pretty much the\nentire required interface for writing.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n3. In many streams, `pause()` was purely advisory, so **even while\n   paused**, you still have to be careful that you might get some\n   data.  This caused a lot of subtle b ugs.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nAnd read consumers had to always be prepared for their backpressure\nadvice to simply be ignored.\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, slicing, and so on.  This\nis all rather brittle and easy to get wrong for all but the most\ntrivial use cases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\n<!-- misc -->\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.  Any data that\nwas already in the process of being read will be placed in a buffer.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.  The\nproblems of data events happening while paused are alleviated.\n\n### Compatibility\n\n<!-- misc -->\n\nIt's not particularly difficult to wrap old-style streams in this\nnew interface, or to wrap this type of stream in the old-style\ninterface.\n\nThe `Readable` class provides a `wrap(oldStream)` method that takes an\nargument which is an old-style stream with `data` events and `pause()`\nand `resume()` methods, and uses that as the data source.  For\nexample:\n\n```javascript\nvar r = new Readable();\nr.wrap(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n// but the data is based on whatever oldReadableStream spits out of\n// its 'data' events.\n```\n\nIn order to work with programs that use the old interface, some\nmagic is unfortunately required.  At some point in the future, this\nmagic will be removed.\n\nThe `Readable` class will automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n  // magic is happening!  oh no!  the animals are walking upright!\n  // the brooms are sweeping the floors all by themselves!\n});\n\n// this will also turn on magic-mode:\nr.pause();\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n\n## Class: Readable\n\nA base class for implementing Readable streams.  Override the\n`_read(n,cb)` method to fetch data asynchronously and take advantage\nof the buffering built into the Readable class.\n\n### Example\n\nExtend the Readable class, and provide a `_read(n,cb)` implementation\nmethod.\n\n```javascript\nvar Readable = require('readable-stream');\nvar util = require('util');\n\nutil.inherits(MyReadable, Readable);\n\nfunction MyReadable(options) {\n  Readable.call(this, options);\n}\n\nMyReadable.prototype._read = function(n, cb) {\n  // your magic goes here.\n  // call the cb at some time in the future with either up to n bytes,\n  // or an error, like cb(err, resultData)\n  //\n  // The code in the Readable class will call this to keep an internal\n  // buffer at a healthy level, as the user calls var chunk=stream.read(n)\n  // to consume chunks.\n};\n\nvar r = new MyReadable();\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n\n// to get some bytes out of it:\nvar data = r.read(optionalLengthArgument);\n// now data is either null, or a buffer of optionalLengthArgument\n// length.  If you don't provide an argument, then it returns whatever\n// it has.\n\n// typically you'd just r.pipe() into some writable stream, but you\n// can of course do stuff like this, as well:\nfunction flow() {\n  var chunk;\n  while (null !== (chunk = r.read())) {\n    doSomethingWithData(chunk);\n  }\n  r.once('readable', flow);\n}\nflow();\n```\n\n### new Readable(options)\n\n* `options` {Object}\n  * `lowWaterMark` {Number} The minimum number of bytes before the\n    stream is considered 'readable'.  Default = `0`\n  * `bufferSize` {Number} The number of bytes to try to read from the\n    underlying `_read` function.  Default = `16 * 1024`\n\nMake sure to call the `Readable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### readable.read([size])\n\n* `size` {Number} Optional number of bytes to read.  If not provided,\n  then return however many bytes are available.\n* Returns: {Buffer | null}\n\nPulls the requested number of bytes out of the internal buffer.  If\nthat many bytes are not available, then it returns `null`.\n\n### readable.\\_read(size, callback)\n\n* `size` {Number} Number of bytes to read from the underlying\n  asynchronous data source.\n* `callback` {Function} Callback function\n  * `error` {Error Object}\n  * `data` {Buffer | null}\n\n**Note: This function is not implemented in the Readable base class.**\nRather, it is up to you to implement `_read` in your extension\nclasses.\n\n`_read` should fetch the specified number of bytes, and call the\nprovided callback with `cb(error, data)`, where `error` is any error\nencountered, and `data` is the returned data.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nThe `size` argument is purely advisory.  You may call the callback\nwith more or fewer bytes.  However, if you call the callback with\n`null`, or an empty buffer, then it will assume that the end of the\ndata was reached.\n\n### readable.pipe(destination)\n\n* `destination` {Writable Stream object}\n\nContinually `read()` data out of the readable stream, and `write()` it\ninto the writable stream.  When the `writable.write(chunk)` call\nreturns `false`, then it will back off until the next `drain` event,\nto do backpressure.\n\nPiping to multiple destinations is supported.  The slowest destination\nstream will limit the speed of the `pipe()` flow.\n\nNote that this puts the readable stream into a state where not very\nmuch can be done with it.  You can no longer `read()` from the stream\nin other code, without upsetting the pipe() process.  However, since\nmultiple pipe destinations are supported, you can always create a\n`PassThrough` stream, and pipe the reader to that.  For example:\n\n```\nvar r = new ReadableWhatever();\nvar pt = new PassThrough();\n\nr.pipe(someWritableThing);\nr.pipe(pt);\n\n// now I can call pt.read() to my heart's content.\n// note that if I *don't* call pt.read(), then it'll back up and\n// prevent the pipe() from flowing!\n```\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream object} Optional\n\nRemove the provided `destination` stream from the pipe flow.  If no\nargument is provided, then it will unhook all piped destinations.\n\n### readable.on('readable')\n\nAn event that signals more data is now available to be read from the\nstream.  Emitted when more data arrives, after previously calling\n`read()` and getting a null result.\n\n### readable.on('end')\n\nAn event that signals that no more data will ever be available on this\nstream.  It's over.\n\n### readable.\\_readableState\n\n* {Object}\n\nAn object that tracks the state of the stream.  Buffer information,\nwhether or not it has reached the end of the underlying data source,\netc., are all tracked on this object.\n\nYou are strongly encouraged not to modify this in any way, but it is\noften useful to read from.\n\n## Class: Writable\n\nA base class for creating Writable streams.  Similar to Readable, you\ncan create child classes by overriding the asynchronous\n`_write(chunk,cb)` method, and it will take care of buffering,\nbackpressure, and so on.\n\n### new Writable(options)\n\n* `options` {Object}\n  * `highWaterMark` {Number} The number of bytes to store up before it\n    starts returning `false` from write() calls.  Default = `16 * 1024`\n  * `lowWaterMark` {Number} The number of bytes that the buffer must\n    get down to before it emits `drain`.  Default = `1024`\n\nMake sure to call the `Writable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### writable.write(chunk, [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String} An encoding argument to turn the string chunk\n  into a buffer.  Only relevant if `chunk` is a string.\n  Default = `'utf8'`.\n* Returns `false` if you should not write until the next `drain`\n  event, or some other value otherwise.\n\nThe basic write function.\n\n### writable.\\_write(chunk, callback)\n\n* `chunk` {Buffer}\n* `callback` {Function}\n  * `error` {Error | null} Call with an error object as the first\n    argument to indicate that the write() failed for unfixable\n    reasons.\n\n**Note: This function is not implemented in the Writable base class.**\nRather, it is up to you to implement `_write` in your extension\nclasses.\n\n`_write` should do whatever has to be done in this specific Writable\nclass, to handle the bytes being written.  Write to a file, send along\na socket, encrypt as an mp3, whatever needs to be done.  Do your I/O\nasynchronously, and call the callback when it's complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### writable.end([chunk], [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String}\n\nIf a chunk (and, optionally, an encoding) are provided, then that\nchunk is first passed to `this.write(chunk, encoding)`.\n\nThis method is a way to signal to the writable stream that you will\nnot be writing any more data.  It should be called exactly once for\nevery writable stream.\n\nCalling `write()` *after* calling `end()` will trigger an error.\n\n### writable.on('pipe', source)\n\nEmitted when calling `source.pipe(writable)`.  See above for the\ndescription of the `readable.pipe()` method.\n\n### writable.on('unpipe', source)\n\nEmitted when calling `source.unpipe(writable)`.  See above for the\ndescription of the `readable.unpipe()` method.\n\n### writable.on('drain')\n\nIf a call to `writable.write()` returns false, then at some point in\nthe future, this event will tell you to start writing again.\n\n### writable.on('finish')\n\nWhen the stream has been ended, and all the data in its internal\nbuffer has been consumed, then it emits a `finish` event to let you\nknow that it's completely done.\n\nThis is particularly handy if you want to know when it is safe to shut\ndown a socket or close a file descriptor.  At this time, the writable\nstream may be safely disposed.  Its mission in life has been\naccomplished.\n\n## Class: Duplex\n\nA base class for Duplex streams (ie, streams that are both readable\nand writable).\n\nSince JS doesn't have multiple prototypal inheritance, this class\nprototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n,cb)` method as well as the lowlevel `_write(chunk,cb)`\nmethod on extension duplex classes.\n\nFor cases where the written data is transformed into the output, it\nmay be simpler to use the `Transform` class instead.\n\n### new Duplex(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Duplex` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\nIf `options.allowHalfOpen` is set to the value `false`, then the\nstream will automatically end the readable side when the writable\nside ends, and vice versa.\n\n### duplex.allowHalfOpen\n\n* {Boolean} Default = `true`\n\nSet this flag to either `true` or `false` to determine whether or not\nto automatically close the writable side when the readable side ends,\nand vice versa.\n\n\n## Class: Transform\n\nA duplex (ie, both readable and writable) stream that is designed to\nmake it easy to implement transform operations such as encryption,\ndecryption, compression, and so on.\n\nTransform streams are `instanceof` Readable, but they have all of the\nmethods and properties of both Readable and Writable streams.  See\nabove for the list of events and methods that Transform inherits from\nWritable and Readable.\n\nOverride the `_transform(chunk, outputFunction, callback)` method in\nyour implementation classes to take advantage of it.\n\n### new Transform(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Transform` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### transform.\\_transform(chunk, outputFn, callback)\n\n* `chunk` {Buffer} The chunk to be transformed.\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_transform` in your extension\nclasses.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that this may mean that you call the `outputFn` zero\nor more times, depending on how much data you want to output as a\nresult of this chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(outputFn, callback)\n\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_flush` in your extension\nclasses optionally, if it applies to your use case.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `outputFn` zero or more times, as\nappropriate, and call `callback` when the flush operation is complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n## Class: PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n","readmeFilename":"README.md","_id":"readable-stream@0.0.4","dist":{"shasum":"f32d76e3fb863344a548d79923007173665b3b8d","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.0.4.tgz"},"_npmVersion":"1.1.68","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"0.1.0":{"name":"readable-stream","version":"0.1.0","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nA new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\nNote that Duplex, Transform, Writable, and PassThrough streams are also\nprovided as base classes.  See the full API details below.\n\n## Justification\n\n<!-- misc -->\n\nWritable streams in node are relatively straightforward to use and\nextend.  The `write` method either returns `false` if you would like\nthe user to back off a bit, in which case a `drain` event at some\npoint in the future will let them continue writing, or anything other\nthan false if the bytes could be completely handled and another\n`write` should be performed, or   The `end()` method lets the user\nindicate that no more bytes will be written.  That's pretty much the\nentire required interface for writing.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n3. In many streams, `pause()` was purely advisory, so **even while\n   paused**, you still have to be careful that you might get some\n   data.  This caused a lot of subtle b ugs.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nAnd read consumers had to always be prepared for their backpressure\nadvice to simply be ignored.\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, slicing, and so on.  This\nis all rather brittle and easy to get wrong for all but the most\ntrivial use cases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\n<!-- misc -->\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.  Any data that\nwas already in the process of being read will be placed in a buffer.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.  The\nproblems of data events happening while paused are alleviated.\n\n### Compatibility\n\n<!-- misc -->\n\nIt's not particularly difficult to wrap old-style streams in this\nnew interface, or to wrap this type of stream in the old-style\ninterface.\n\nThe `Readable` class provides a `wrap(oldStream)` method that takes an\nargument which is an old-style stream with `data` events and `pause()`\nand `resume()` methods, and uses that as the data source.  For\nexample:\n\n```javascript\nvar r = new Readable();\nr.wrap(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n// but the data is based on whatever oldReadableStream spits out of\n// its 'data' events.\n```\n\nIn order to work with programs that use the old interface, some\nmagic is unfortunately required.  At some point in the future, this\nmagic will be removed.\n\nThe `Readable` class will automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n  // magic is happening!  oh no!  the animals are walking upright!\n  // the brooms are sweeping the floors all by themselves!\n});\n\n// this will also turn on magic-mode:\nr.pause();\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n\n## Class: Readable\n\nA base class for implementing Readable streams.  Override the\n`_read(n,cb)` method to fetch data asynchronously and take advantage\nof the buffering built into the Readable class.\n\n### Example\n\nExtend the Readable class, and provide a `_read(n,cb)` implementation\nmethod.\n\n```javascript\nvar Readable = require('readable-stream');\nvar util = require('util');\n\nutil.inherits(MyReadable, Readable);\n\nfunction MyReadable(options) {\n  Readable.call(this, options);\n}\n\nMyReadable.prototype._read = function(n, cb) {\n  // your magic goes here.\n  // call the cb at some time in the future with either up to n bytes,\n  // or an error, like cb(err, resultData)\n  //\n  // The code in the Readable class will call this to keep an internal\n  // buffer at a healthy level, as the user calls var chunk=stream.read(n)\n  // to consume chunks.\n};\n\nvar r = new MyReadable();\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n\n// to get some bytes out of it:\nvar data = r.read(optionalLengthArgument);\n// now data is either null, or a buffer of optionalLengthArgument\n// length.  If you don't provide an argument, then it returns whatever\n// it has.\n\n// typically you'd just r.pipe() into some writable stream, but you\n// can of course do stuff like this, as well:\nfunction flow() {\n  var chunk;\n  while (null !== (chunk = r.read())) {\n    doSomethingWithData(chunk);\n  }\n  r.once('readable', flow);\n}\nflow();\n```\n\n### new Readable(options)\n\n* `options` {Object}\n  * `lowWaterMark` {Number} The minimum number of bytes before the\n    stream is considered 'readable'.  Default = `0`\n  * `bufferSize` {Number} The number of bytes to try to read from the\n    underlying `_read` function.  Default = `16 * 1024`\n\nMake sure to call the `Readable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### readable.read([size])\n\n* `size` {Number} Optional number of bytes to read.  If not provided,\n  then return however many bytes are available.\n* Returns: {Buffer | null}\n\nPulls the requested number of bytes out of the internal buffer.  If\nthat many bytes are not available, then it returns `null`.\n\n### readable.\\_read(size, callback)\n\n* `size` {Number} Number of bytes to read from the underlying\n  asynchronous data source.\n* `callback` {Function} Callback function\n  * `error` {Error Object}\n  * `data` {Buffer | null}\n\n**Note: This function is not implemented in the Readable base class.**\nRather, it is up to you to implement `_read` in your extension\nclasses.\n\n`_read` should fetch the specified number of bytes, and call the\nprovided callback with `cb(error, data)`, where `error` is any error\nencountered, and `data` is the returned data.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nThe `size` argument is purely advisory.  You may call the callback\nwith more or fewer bytes.  However, if you call the callback with\n`null`, or an empty buffer, then it will assume that the end of the\ndata was reached.\n\n### readable.pipe(destination)\n\n* `destination` {Writable Stream object}\n\nContinually `read()` data out of the readable stream, and `write()` it\ninto the writable stream.  When the `writable.write(chunk)` call\nreturns `false`, then it will back off until the next `drain` event,\nto do backpressure.\n\nPiping to multiple destinations is supported.  The slowest destination\nstream will limit the speed of the `pipe()` flow.\n\nNote that this puts the readable stream into a state where not very\nmuch can be done with it.  You can no longer `read()` from the stream\nin other code, without upsetting the pipe() process.  However, since\nmultiple pipe destinations are supported, you can always create a\n`PassThrough` stream, and pipe the reader to that.  For example:\n\n```\nvar r = new ReadableWhatever();\nvar pt = new PassThrough();\n\nr.pipe(someWritableThing);\nr.pipe(pt);\n\n// now I can call pt.read() to my heart's content.\n// note that if I *don't* call pt.read(), then it'll back up and\n// prevent the pipe() from flowing!\n```\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream object} Optional\n\nRemove the provided `destination` stream from the pipe flow.  If no\nargument is provided, then it will unhook all piped destinations.\n\n### readable.on('readable')\n\nAn event that signals more data is now available to be read from the\nstream.  Emitted when more data arrives, after previously calling\n`read()` and getting a null result.\n\n### readable.on('end')\n\nAn event that signals that no more data will ever be available on this\nstream.  It's over.\n\n### readable.\\_readableState\n\n* {Object}\n\nAn object that tracks the state of the stream.  Buffer information,\nwhether or not it has reached the end of the underlying data source,\netc., are all tracked on this object.\n\nYou are strongly encouraged not to modify this in any way, but it is\noften useful to read from.\n\n## Class: Writable\n\nA base class for creating Writable streams.  Similar to Readable, you\ncan create child classes by overriding the asynchronous\n`_write(chunk,cb)` method, and it will take care of buffering,\nbackpressure, and so on.\n\n### new Writable(options)\n\n* `options` {Object}\n  * `highWaterMark` {Number} The number of bytes to store up before it\n    starts returning `false` from write() calls.  Default = `16 * 1024`\n  * `lowWaterMark` {Number} The number of bytes that the buffer must\n    get down to before it emits `drain`.  Default = `1024`\n\nMake sure to call the `Writable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### writable.write(chunk, [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String} An encoding argument to turn the string chunk\n  into a buffer.  Only relevant if `chunk` is a string.\n  Default = `'utf8'`.\n* Returns `false` if you should not write until the next `drain`\n  event, or some other value otherwise.\n\nThe basic write function.\n\n### writable.\\_write(chunk, callback)\n\n* `chunk` {Buffer}\n* `callback` {Function}\n  * `error` {Error | null} Call with an error object as the first\n    argument to indicate that the write() failed for unfixable\n    reasons.\n\n**Note: This function is not implemented in the Writable base class.**\nRather, it is up to you to implement `_write` in your extension\nclasses.\n\n`_write` should do whatever has to be done in this specific Writable\nclass, to handle the bytes being written.  Write to a file, send along\na socket, encrypt as an mp3, whatever needs to be done.  Do your I/O\nasynchronously, and call the callback when it's complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### writable.end([chunk], [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String}\n\nIf a chunk (and, optionally, an encoding) are provided, then that\nchunk is first passed to `this.write(chunk, encoding)`.\n\nThis method is a way to signal to the writable stream that you will\nnot be writing any more data.  It should be called exactly once for\nevery writable stream.\n\nCalling `write()` *after* calling `end()` will trigger an error.\n\n### writable.on('pipe', source)\n\nEmitted when calling `source.pipe(writable)`.  See above for the\ndescription of the `readable.pipe()` method.\n\n### writable.on('unpipe', source)\n\nEmitted when calling `source.unpipe(writable)`.  See above for the\ndescription of the `readable.unpipe()` method.\n\n### writable.on('drain')\n\nIf a call to `writable.write()` returns false, then at some point in\nthe future, this event will tell you to start writing again.\n\n### writable.on('finish')\n\nWhen the stream has been ended, and all the data in its internal\nbuffer has been consumed, then it emits a `finish` event to let you\nknow that it's completely done.\n\nThis is particularly handy if you want to know when it is safe to shut\ndown a socket or close a file descriptor.  At this time, the writable\nstream may be safely disposed.  Its mission in life has been\naccomplished.\n\n## Class: Duplex\n\nA base class for Duplex streams (ie, streams that are both readable\nand writable).\n\nSince JS doesn't have multiple prototypal inheritance, this class\nprototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n,cb)` method as well as the lowlevel `_write(chunk,cb)`\nmethod on extension duplex classes.\n\nFor cases where the written data is transformed into the output, it\nmay be simpler to use the `Transform` class instead.\n\n### new Duplex(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Duplex` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\nIf `options.allowHalfOpen` is set to the value `false`, then the\nstream will automatically end the readable side when the writable\nside ends, and vice versa.\n\n### duplex.allowHalfOpen\n\n* {Boolean} Default = `true`\n\nSet this flag to either `true` or `false` to determine whether or not\nto automatically close the writable side when the readable side ends,\nand vice versa.\n\n\n## Class: Transform\n\nA duplex (ie, both readable and writable) stream that is designed to\nmake it easy to implement transform operations such as encryption,\ndecryption, compression, and so on.\n\nTransform streams are `instanceof` Readable, but they have all of the\nmethods and properties of both Readable and Writable streams.  See\nabove for the list of events and methods that Transform inherits from\nWritable and Readable.\n\nOverride the `_transform(chunk, outputFunction, callback)` method in\nyour implementation classes to take advantage of it.\n\n### new Transform(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Transform` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### transform.\\_transform(chunk, outputFn, callback)\n\n* `chunk` {Buffer} The chunk to be transformed.\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_transform` in your extension\nclasses.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that this may mean that you call the `outputFn` zero\nor more times, depending on how much data you want to output as a\nresult of this chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(outputFn, callback)\n\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_flush` in your extension\nclasses optionally, if it applies to your use case.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `outputFn` zero or more times, as\nappropriate, and call `callback` when the flush operation is complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n## Class: PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n","readmeFilename":"README.md","_id":"readable-stream@0.1.0","dist":{"shasum":"35476301be1584653b5a0101f288cd40b33cf39e","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.1.0.tgz"},"_npmVersion":"1.1.69","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"0.2.0":{"name":"readable-stream","version":"0.2.0","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nA new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\nNote that Duplex, Transform, Writable, and PassThrough streams are also\nprovided as base classes.  See the full API details below.\n\n## Justification\n\n<!-- misc -->\n\nWritable streams in node are relatively straightforward to use and\nextend.  The `write` method either returns `false` if you would like\nthe user to back off a bit, in which case a `drain` event at some\npoint in the future will let them continue writing, or anything other\nthan false if the bytes could be completely handled and another\n`write` should be performed, or   The `end()` method lets the user\nindicate that no more bytes will be written.  That's pretty much the\nentire required interface for writing.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n3. In many streams, `pause()` was purely advisory, so **even while\n   paused**, you still have to be careful that you might get some\n   data.  This caused a lot of subtle b ugs.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nAnd read consumers had to always be prepared for their backpressure\nadvice to simply be ignored.\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, slicing, and so on.  This\nis all rather brittle and easy to get wrong for all but the most\ntrivial use cases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\n<!-- misc -->\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.  Any data that\nwas already in the process of being read will be placed in a buffer.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.  The\nproblems of data events happening while paused are alleviated.\n\n### Compatibility\n\n<!-- misc -->\n\nIt's not particularly difficult to wrap old-style streams in this\nnew interface, or to wrap this type of stream in the old-style\ninterface.\n\nThe `Readable` class provides a `wrap(oldStream)` method that takes an\nargument which is an old-style stream with `data` events and `pause()`\nand `resume()` methods, and uses that as the data source.  For\nexample:\n\n```javascript\nvar r = new Readable();\nr.wrap(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n// but the data is based on whatever oldReadableStream spits out of\n// its 'data' events.\n```\n\nIn order to work with programs that use the old interface, some\nmagic is unfortunately required.  At some point in the future, this\nmagic will be removed.\n\nThe `Readable` class will automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n  // magic is happening!  oh no!  the animals are walking upright!\n  // the brooms are sweeping the floors all by themselves!\n});\n\n// this will also turn on magic-mode:\nr.pause();\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n\n## Class: Readable\n\nA base class for implementing Readable streams.  Override the\n`_read(n,cb)` method to fetch data asynchronously and take advantage\nof the buffering built into the Readable class.\n\n### Example\n\nExtend the Readable class, and provide a `_read(n,cb)` implementation\nmethod.\n\n```javascript\nvar Readable = require('readable-stream');\nvar util = require('util');\n\nutil.inherits(MyReadable, Readable);\n\nfunction MyReadable(options) {\n  Readable.call(this, options);\n}\n\nMyReadable.prototype._read = function(n, cb) {\n  // your magic goes here.\n  // call the cb at some time in the future with either up to n bytes,\n  // or an error, like cb(err, resultData)\n  //\n  // The code in the Readable class will call this to keep an internal\n  // buffer at a healthy level, as the user calls var chunk=stream.read(n)\n  // to consume chunks.\n};\n\nvar r = new MyReadable();\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n\n// to get some bytes out of it:\nvar data = r.read(optionalLengthArgument);\n// now data is either null, or a buffer of optionalLengthArgument\n// length.  If you don't provide an argument, then it returns whatever\n// it has.\n\n// typically you'd just r.pipe() into some writable stream, but you\n// can of course do stuff like this, as well:\nfunction flow() {\n  var chunk;\n  while (null !== (chunk = r.read())) {\n    doSomethingWithData(chunk);\n  }\n  r.once('readable', flow);\n}\nflow();\n```\n\n### new Readable(options)\n\n* `options` {Object}\n  * `lowWaterMark` {Number} The minimum number of bytes before the\n    stream is considered 'readable'.  Default = `0`\n  * `bufferSize` {Number} The number of bytes to try to read from the\n    underlying `_read` function.  Default = `16 * 1024`\n\nMake sure to call the `Readable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### readable.read([size])\n\n* `size` {Number} Optional number of bytes to read.  If not provided,\n  then return however many bytes are available.\n* Returns: {Buffer | null}\n\nPulls the requested number of bytes out of the internal buffer.  If\nthat many bytes are not available, then it returns `null`.\n\n### readable.\\_read(size, callback)\n\n* `size` {Number} Number of bytes to read from the underlying\n  asynchronous data source.\n* `callback` {Function} Callback function\n  * `error` {Error Object}\n  * `data` {Buffer | null}\n\n**Note: This function is not implemented in the Readable base class.**\nRather, it is up to you to implement `_read` in your extension\nclasses.\n\n`_read` should fetch the specified number of bytes, and call the\nprovided callback with `cb(error, data)`, where `error` is any error\nencountered, and `data` is the returned data.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nThe `size` argument is purely advisory.  You may call the callback\nwith more or fewer bytes.  However, if you call the callback with\n`null`, or an empty buffer, then it will assume that the end of the\ndata was reached.\n\n### readable.pipe(destination)\n\n* `destination` {Writable Stream object}\n\nContinually `read()` data out of the readable stream, and `write()` it\ninto the writable stream.  When the `writable.write(chunk)` call\nreturns `false`, then it will back off until the next `drain` event,\nto do backpressure.\n\nPiping to multiple destinations is supported.  The slowest destination\nstream will limit the speed of the `pipe()` flow.\n\nNote that this puts the readable stream into a state where not very\nmuch can be done with it.  You can no longer `read()` from the stream\nin other code, without upsetting the pipe() process.  However, since\nmultiple pipe destinations are supported, you can always create a\n`PassThrough` stream, and pipe the reader to that.  For example:\n\n```\nvar r = new ReadableWhatever();\nvar pt = new PassThrough();\n\nr.pipe(someWritableThing);\nr.pipe(pt);\n\n// now I can call pt.read() to my heart's content.\n// note that if I *don't* call pt.read(), then it'll back up and\n// prevent the pipe() from flowing!\n```\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream object} Optional\n\nRemove the provided `destination` stream from the pipe flow.  If no\nargument is provided, then it will unhook all piped destinations.\n\n### readable.on('readable')\n\nAn event that signals more data is now available to be read from the\nstream.  Emitted when more data arrives, after previously calling\n`read()` and getting a null result.\n\n### readable.on('end')\n\nAn event that signals that no more data will ever be available on this\nstream.  It's over.\n\n### readable.\\_readableState\n\n* {Object}\n\nAn object that tracks the state of the stream.  Buffer information,\nwhether or not it has reached the end of the underlying data source,\netc., are all tracked on this object.\n\nYou are strongly encouraged not to modify this in any way, but it is\noften useful to read from.\n\n## Class: Writable\n\nA base class for creating Writable streams.  Similar to Readable, you\ncan create child classes by overriding the asynchronous\n`_write(chunk,cb)` method, and it will take care of buffering,\nbackpressure, and so on.\n\n### new Writable(options)\n\n* `options` {Object}\n  * `highWaterMark` {Number} The number of bytes to store up before it\n    starts returning `false` from write() calls.  Default = `16 * 1024`\n  * `lowWaterMark` {Number} The number of bytes that the buffer must\n    get down to before it emits `drain`.  Default = `1024`\n\nMake sure to call the `Writable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### writable.write(chunk, [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String} An encoding argument to turn the string chunk\n  into a buffer.  Only relevant if `chunk` is a string.\n  Default = `'utf8'`.\n* Returns `false` if you should not write until the next `drain`\n  event, or some other value otherwise.\n\nThe basic write function.\n\n### writable.\\_write(chunk, callback)\n\n* `chunk` {Buffer}\n* `callback` {Function}\n  * `error` {Error | null} Call with an error object as the first\n    argument to indicate that the write() failed for unfixable\n    reasons.\n\n**Note: This function is not implemented in the Writable base class.**\nRather, it is up to you to implement `_write` in your extension\nclasses.\n\n`_write` should do whatever has to be done in this specific Writable\nclass, to handle the bytes being written.  Write to a file, send along\na socket, encrypt as an mp3, whatever needs to be done.  Do your I/O\nasynchronously, and call the callback when it's complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### writable.end([chunk], [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String}\n\nIf a chunk (and, optionally, an encoding) are provided, then that\nchunk is first passed to `this.write(chunk, encoding)`.\n\nThis method is a way to signal to the writable stream that you will\nnot be writing any more data.  It should be called exactly once for\nevery writable stream.\n\nCalling `write()` *after* calling `end()` will trigger an error.\n\n### writable.on('pipe', source)\n\nEmitted when calling `source.pipe(writable)`.  See above for the\ndescription of the `readable.pipe()` method.\n\n### writable.on('unpipe', source)\n\nEmitted when calling `source.unpipe(writable)`.  See above for the\ndescription of the `readable.unpipe()` method.\n\n### writable.on('drain')\n\nIf a call to `writable.write()` returns false, then at some point in\nthe future, this event will tell you to start writing again.\n\n### writable.on('finish')\n\nWhen the stream has been ended, and all the data in its internal\nbuffer has been consumed, then it emits a `finish` event to let you\nknow that it's completely done.\n\nThis is particularly handy if you want to know when it is safe to shut\ndown a socket or close a file descriptor.  At this time, the writable\nstream may be safely disposed.  Its mission in life has been\naccomplished.\n\n## Class: Duplex\n\nA base class for Duplex streams (ie, streams that are both readable\nand writable).\n\nSince JS doesn't have multiple prototypal inheritance, this class\nprototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n,cb)` method as well as the lowlevel `_write(chunk,cb)`\nmethod on extension duplex classes.\n\nFor cases where the written data is transformed into the output, it\nmay be simpler to use the `Transform` class instead.\n\n### new Duplex(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Duplex` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\nIf `options.allowHalfOpen` is set to the value `false`, then the\nstream will automatically end the readable side when the writable\nside ends, and vice versa.\n\n### duplex.allowHalfOpen\n\n* {Boolean} Default = `true`\n\nSet this flag to either `true` or `false` to determine whether or not\nto automatically close the writable side when the readable side ends,\nand vice versa.\n\n\n## Class: Transform\n\nA duplex (ie, both readable and writable) stream that is designed to\nmake it easy to implement transform operations such as encryption,\ndecryption, compression, and so on.\n\nTransform streams are `instanceof` Readable, but they have all of the\nmethods and properties of both Readable and Writable streams.  See\nabove for the list of events and methods that Transform inherits from\nWritable and Readable.\n\nOverride the `_transform(chunk, outputFunction, callback)` method in\nyour implementation classes to take advantage of it.\n\n### new Transform(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Transform` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### transform.\\_transform(chunk, outputFn, callback)\n\n* `chunk` {Buffer} The chunk to be transformed.\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_transform` in your extension\nclasses.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that this may mean that you call the `outputFn` zero\nor more times, depending on how much data you want to output as a\nresult of this chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(outputFn, callback)\n\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_flush` in your extension\nclasses optionally, if it applies to your use case.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `outputFn` zero or more times, as\nappropriate, and call `callback` when the flush operation is complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n## Class: PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n","readmeFilename":"README.md","_id":"readable-stream@0.2.0","dist":{"shasum":"c237bf773b27acf9472a576435a9cb9b71504e0d","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.2.0.tgz"},"_npmVersion":"1.2.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"0.3.0":{"name":"readable-stream","version":"0.3.0","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nA new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\nNote that Duplex, Transform, Writable, and PassThrough streams are also\nprovided as base classes.  See the full API details below.\n\n## Justification\n\n<!-- misc -->\n\nWritable streams in node are relatively straightforward to use and\nextend.  The `write` method either returns `false` if you would like\nthe user to back off a bit, in which case a `drain` event at some\npoint in the future will let them continue writing, or anything other\nthan false if the bytes could be completely handled and another\n`write` should be performed, or   The `end()` method lets the user\nindicate that no more bytes will be written.  That's pretty much the\nentire required interface for writing.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n3. In many streams, `pause()` was purely advisory, so **even while\n   paused**, you still have to be careful that you might get some\n   data.  This caused a lot of subtle b ugs.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nAnd read consumers had to always be prepared for their backpressure\nadvice to simply be ignored.\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, slicing, and so on.  This\nis all rather brittle and easy to get wrong for all but the most\ntrivial use cases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\n<!-- misc -->\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.  Any data that\nwas already in the process of being read will be placed in a buffer.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.  The\nproblems of data events happening while paused are alleviated.\n\n### Compatibility\n\n<!-- misc -->\n\nIt's not particularly difficult to wrap old-style streams in this\nnew interface, or to wrap this type of stream in the old-style\ninterface.\n\nThe `Readable` class provides a `wrap(oldStream)` method that takes an\nargument which is an old-style stream with `data` events and `pause()`\nand `resume()` methods, and uses that as the data source.  For\nexample:\n\n```javascript\nvar r = new Readable();\nr.wrap(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n// but the data is based on whatever oldReadableStream spits out of\n// its 'data' events.\n```\n\nIn order to work with programs that use the old interface, some\nmagic is unfortunately required.  At some point in the future, this\nmagic will be removed.\n\nThe `Readable` class will automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n  // magic is happening!  oh no!  the animals are walking upright!\n  // the brooms are sweeping the floors all by themselves!\n});\n\n// this will also turn on magic-mode:\nr.pause();\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n\n## Class: Readable\n\nA base class for implementing Readable streams.  Override the\n`_read(n,cb)` method to fetch data asynchronously and take advantage\nof the buffering built into the Readable class.\n\n### Example\n\nExtend the Readable class, and provide a `_read(n,cb)` implementation\nmethod.\n\n```javascript\nvar Readable = require('readable-stream');\nvar util = require('util');\n\nutil.inherits(MyReadable, Readable);\n\nfunction MyReadable(options) {\n  Readable.call(this, options);\n}\n\nMyReadable.prototype._read = function(n, cb) {\n  // your magic goes here.\n  // call the cb at some time in the future with either up to n bytes,\n  // or an error, like cb(err, resultData)\n  //\n  // The code in the Readable class will call this to keep an internal\n  // buffer at a healthy level, as the user calls var chunk=stream.read(n)\n  // to consume chunks.\n};\n\nvar r = new MyReadable();\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n\n// to get some bytes out of it:\nvar data = r.read(optionalLengthArgument);\n// now data is either null, or a buffer of optionalLengthArgument\n// length.  If you don't provide an argument, then it returns whatever\n// it has.\n\n// typically you'd just r.pipe() into some writable stream, but you\n// can of course do stuff like this, as well:\nfunction flow() {\n  var chunk;\n  while (null !== (chunk = r.read())) {\n    doSomethingWithData(chunk);\n  }\n  r.once('readable', flow);\n}\nflow();\n```\n\n### new Readable(options)\n\n* `options` {Object}\n  * `lowWaterMark` {Number} The minimum number of bytes before the\n    stream is considered 'readable'.  Default = `0`\n  * `bufferSize` {Number} The number of bytes to try to read from the\n    underlying `_read` function.  Default = `16 * 1024`\n\nMake sure to call the `Readable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### readable.read([size])\n\n* `size` {Number} Optional number of bytes to read.  If not provided,\n  then return however many bytes are available.\n* Returns: {Buffer | null}\n\nPulls the requested number of bytes out of the internal buffer.  If\nthat many bytes are not available, then it returns `null`.\n\n### readable.\\_read(size, callback)\n\n* `size` {Number} Number of bytes to read from the underlying\n  asynchronous data source.\n* `callback` {Function} Callback function\n  * `error` {Error Object}\n  * `data` {Buffer | null}\n\n**Note: This function is not implemented in the Readable base class.**\nRather, it is up to you to implement `_read` in your extension\nclasses.\n\n`_read` should fetch the specified number of bytes, and call the\nprovided callback with `cb(error, data)`, where `error` is any error\nencountered, and `data` is the returned data.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nThe `size` argument is purely advisory.  You may call the callback\nwith more or fewer bytes.  However, if you call the callback with\n`null`, or an empty buffer, then it will assume that the end of the\ndata was reached.\n\n### readable.pipe(destination)\n\n* `destination` {Writable Stream object}\n\nContinually `read()` data out of the readable stream, and `write()` it\ninto the writable stream.  When the `writable.write(chunk)` call\nreturns `false`, then it will back off until the next `drain` event,\nto do backpressure.\n\nPiping to multiple destinations is supported.  The slowest destination\nstream will limit the speed of the `pipe()` flow.\n\nNote that this puts the readable stream into a state where not very\nmuch can be done with it.  You can no longer `read()` from the stream\nin other code, without upsetting the pipe() process.  However, since\nmultiple pipe destinations are supported, you can always create a\n`PassThrough` stream, and pipe the reader to that.  For example:\n\n```\nvar r = new ReadableWhatever();\nvar pt = new PassThrough();\n\nr.pipe(someWritableThing);\nr.pipe(pt);\n\n// now I can call pt.read() to my heart's content.\n// note that if I *don't* call pt.read(), then it'll back up and\n// prevent the pipe() from flowing!\n```\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream object} Optional\n\nRemove the provided `destination` stream from the pipe flow.  If no\nargument is provided, then it will unhook all piped destinations.\n\n### readable.on('readable')\n\nAn event that signals more data is now available to be read from the\nstream.  Emitted when more data arrives, after previously calling\n`read()` and getting a null result.\n\n### readable.on('end')\n\nAn event that signals that no more data will ever be available on this\nstream.  It's over.\n\n### readable.\\_readableState\n\n* {Object}\n\nAn object that tracks the state of the stream.  Buffer information,\nwhether or not it has reached the end of the underlying data source,\netc., are all tracked on this object.\n\nYou are strongly encouraged not to modify this in any way, but it is\noften useful to read from.\n\n## Class: Writable\n\nA base class for creating Writable streams.  Similar to Readable, you\ncan create child classes by overriding the asynchronous\n`_write(chunk,cb)` method, and it will take care of buffering,\nbackpressure, and so on.\n\n### new Writable(options)\n\n* `options` {Object}\n  * `highWaterMark` {Number} The number of bytes to store up before it\n    starts returning `false` from write() calls.  Default = `16 * 1024`\n  * `lowWaterMark` {Number} The number of bytes that the buffer must\n    get down to before it emits `drain`.  Default = `1024`\n\nMake sure to call the `Writable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### writable.write(chunk, [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String} An encoding argument to turn the string chunk\n  into a buffer.  Only relevant if `chunk` is a string.\n  Default = `'utf8'`.\n* Returns `false` if you should not write until the next `drain`\n  event, or some other value otherwise.\n\nThe basic write function.\n\n### writable.\\_write(chunk, callback)\n\n* `chunk` {Buffer}\n* `callback` {Function}\n  * `error` {Error | null} Call with an error object as the first\n    argument to indicate that the write() failed for unfixable\n    reasons.\n\n**Note: This function is not implemented in the Writable base class.**\nRather, it is up to you to implement `_write` in your extension\nclasses.\n\n`_write` should do whatever has to be done in this specific Writable\nclass, to handle the bytes being written.  Write to a file, send along\na socket, encrypt as an mp3, whatever needs to be done.  Do your I/O\nasynchronously, and call the callback when it's complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### writable.end([chunk], [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String}\n\nIf a chunk (and, optionally, an encoding) are provided, then that\nchunk is first passed to `this.write(chunk, encoding)`.\n\nThis method is a way to signal to the writable stream that you will\nnot be writing any more data.  It should be called exactly once for\nevery writable stream.\n\nCalling `write()` *after* calling `end()` will trigger an error.\n\n### writable.on('pipe', source)\n\nEmitted when calling `source.pipe(writable)`.  See above for the\ndescription of the `readable.pipe()` method.\n\n### writable.on('unpipe', source)\n\nEmitted when calling `source.unpipe(writable)`.  See above for the\ndescription of the `readable.unpipe()` method.\n\n### writable.on('drain')\n\nIf a call to `writable.write()` returns false, then at some point in\nthe future, this event will tell you to start writing again.\n\n### writable.on('finish')\n\nWhen the stream has been ended, and all the data in its internal\nbuffer has been consumed, then it emits a `finish` event to let you\nknow that it's completely done.\n\nThis is particularly handy if you want to know when it is safe to shut\ndown a socket or close a file descriptor.  At this time, the writable\nstream may be safely disposed.  Its mission in life has been\naccomplished.\n\n## Class: Duplex\n\nA base class for Duplex streams (ie, streams that are both readable\nand writable).\n\nSince JS doesn't have multiple prototypal inheritance, this class\nprototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n,cb)` method as well as the lowlevel `_write(chunk,cb)`\nmethod on extension duplex classes.\n\nFor cases where the written data is transformed into the output, it\nmay be simpler to use the `Transform` class instead.\n\n### new Duplex(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Duplex` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\nIf `options.allowHalfOpen` is set to the value `false`, then the\nstream will automatically end the readable side when the writable\nside ends, and vice versa.\n\n### duplex.allowHalfOpen\n\n* {Boolean} Default = `true`\n\nSet this flag to either `true` or `false` to determine whether or not\nto automatically close the writable side when the readable side ends,\nand vice versa.\n\n\n## Class: Transform\n\nA duplex (ie, both readable and writable) stream that is designed to\nmake it easy to implement transform operations such as encryption,\ndecryption, compression, and so on.\n\nTransform streams are `instanceof` Readable, but they have all of the\nmethods and properties of both Readable and Writable streams.  See\nabove for the list of events and methods that Transform inherits from\nWritable and Readable.\n\nOverride the `_transform(chunk, outputFunction, callback)` method in\nyour implementation classes to take advantage of it.\n\n### new Transform(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Transform` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### transform.\\_transform(chunk, outputFn, callback)\n\n* `chunk` {Buffer} The chunk to be transformed.\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_transform` in your extension\nclasses.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that this may mean that you call the `outputFn` zero\nor more times, depending on how much data you want to output as a\nresult of this chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(outputFn, callback)\n\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_flush` in your extension\nclasses optionally, if it applies to your use case.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `outputFn` zero or more times, as\nappropriate, and call `callback` when the flush operation is complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n## Class: PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n","readmeFilename":"README.md","_id":"readable-stream@0.3.0","dist":{"shasum":"9ae8f414672ded571ca65b5ce12e7f03e5ec4452","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.3.0.tgz"},"_from":".","_npmVersion":"1.2.10","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"0.3.1":{"name":"readable-stream","version":"0.3.1","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nA new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\nNote that Duplex, Transform, Writable, and PassThrough streams are also\nprovided as base classes.  See the full API details below.\n\n## Justification\n\n<!-- misc -->\n\nWritable streams in node are relatively straightforward to use and\nextend.  The `write` method either returns `false` if you would like\nthe user to back off a bit, in which case a `drain` event at some\npoint in the future will let them continue writing, or anything other\nthan false if the bytes could be completely handled and another\n`write` should be performed, or   The `end()` method lets the user\nindicate that no more bytes will be written.  That's pretty much the\nentire required interface for writing.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n3. In many streams, `pause()` was purely advisory, so **even while\n   paused**, you still have to be careful that you might get some\n   data.  This caused a lot of subtle b ugs.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nAnd read consumers had to always be prepared for their backpressure\nadvice to simply be ignored.\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, slicing, and so on.  This\nis all rather brittle and easy to get wrong for all but the most\ntrivial use cases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\n<!-- misc -->\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.  Any data that\nwas already in the process of being read will be placed in a buffer.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.  The\nproblems of data events happening while paused are alleviated.\n\n### Compatibility\n\n<!-- misc -->\n\nIt's not particularly difficult to wrap old-style streams in this\nnew interface, or to wrap this type of stream in the old-style\ninterface.\n\nThe `Readable` class provides a `wrap(oldStream)` method that takes an\nargument which is an old-style stream with `data` events and `pause()`\nand `resume()` methods, and uses that as the data source.  For\nexample:\n\n```javascript\nvar r = new Readable();\nr.wrap(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n// but the data is based on whatever oldReadableStream spits out of\n// its 'data' events.\n```\n\nIn order to work with programs that use the old interface, some\nmagic is unfortunately required.  At some point in the future, this\nmagic will be removed.\n\nThe `Readable` class will automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n  // magic is happening!  oh no!  the animals are walking upright!\n  // the brooms are sweeping the floors all by themselves!\n});\n\n// this will also turn on magic-mode:\nr.pause();\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n\n## Class: Readable\n\nA base class for implementing Readable streams.  Override the\n`_read(n,cb)` method to fetch data asynchronously and take advantage\nof the buffering built into the Readable class.\n\n### Example\n\nExtend the Readable class, and provide a `_read(n,cb)` implementation\nmethod.\n\n```javascript\nvar Readable = require('readable-stream');\nvar util = require('util');\n\nutil.inherits(MyReadable, Readable);\n\nfunction MyReadable(options) {\n  Readable.call(this, options);\n}\n\nMyReadable.prototype._read = function(n, cb) {\n  // your magic goes here.\n  // call the cb at some time in the future with either up to n bytes,\n  // or an error, like cb(err, resultData)\n  //\n  // The code in the Readable class will call this to keep an internal\n  // buffer at a healthy level, as the user calls var chunk=stream.read(n)\n  // to consume chunks.\n};\n\nvar r = new MyReadable();\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n\n// to get some bytes out of it:\nvar data = r.read(optionalLengthArgument);\n// now data is either null, or a buffer of optionalLengthArgument\n// length.  If you don't provide an argument, then it returns whatever\n// it has.\n\n// typically you'd just r.pipe() into some writable stream, but you\n// can of course do stuff like this, as well:\nfunction flow() {\n  var chunk;\n  while (null !== (chunk = r.read())) {\n    doSomethingWithData(chunk);\n  }\n  r.once('readable', flow);\n}\nflow();\n```\n\n### new Readable(options)\n\n* `options` {Object}\n  * `lowWaterMark` {Number} The minimum number of bytes before the\n    stream is considered 'readable'.  Default = `0`\n  * `bufferSize` {Number} The number of bytes to try to read from the\n    underlying `_read` function.  Default = `16 * 1024`\n\nMake sure to call the `Readable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### readable.read([size])\n\n* `size` {Number} Optional number of bytes to read.  If not provided,\n  then return however many bytes are available.\n* Returns: {Buffer | null}\n\nPulls the requested number of bytes out of the internal buffer.  If\nthat many bytes are not available, then it returns `null`.\n\n### readable.\\_read(size, callback)\n\n* `size` {Number} Number of bytes to read from the underlying\n  asynchronous data source.\n* `callback` {Function} Callback function\n  * `error` {Error Object}\n  * `data` {Buffer | null}\n\n**Note: This function is not implemented in the Readable base class.**\nRather, it is up to you to implement `_read` in your extension\nclasses.\n\n`_read` should fetch the specified number of bytes, and call the\nprovided callback with `cb(error, data)`, where `error` is any error\nencountered, and `data` is the returned data.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nThe `size` argument is purely advisory.  You may call the callback\nwith more or fewer bytes.  However, if you call the callback with\n`null`, or an empty buffer, then it will assume that the end of the\ndata was reached.\n\n### readable.pipe(destination)\n\n* `destination` {Writable Stream object}\n\nContinually `read()` data out of the readable stream, and `write()` it\ninto the writable stream.  When the `writable.write(chunk)` call\nreturns `false`, then it will back off until the next `drain` event,\nto do backpressure.\n\nPiping to multiple destinations is supported.  The slowest destination\nstream will limit the speed of the `pipe()` flow.\n\nNote that this puts the readable stream into a state where not very\nmuch can be done with it.  You can no longer `read()` from the stream\nin other code, without upsetting the pipe() process.  However, since\nmultiple pipe destinations are supported, you can always create a\n`PassThrough` stream, and pipe the reader to that.  For example:\n\n```\nvar r = new ReadableWhatever();\nvar pt = new PassThrough();\n\nr.pipe(someWritableThing);\nr.pipe(pt);\n\n// now I can call pt.read() to my heart's content.\n// note that if I *don't* call pt.read(), then it'll back up and\n// prevent the pipe() from flowing!\n```\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream object} Optional\n\nRemove the provided `destination` stream from the pipe flow.  If no\nargument is provided, then it will unhook all piped destinations.\n\n### readable.on('readable')\n\nAn event that signals more data is now available to be read from the\nstream.  Emitted when more data arrives, after previously calling\n`read()` and getting a null result.\n\n### readable.on('end')\n\nAn event that signals that no more data will ever be available on this\nstream.  It's over.\n\n### readable.\\_readableState\n\n* {Object}\n\nAn object that tracks the state of the stream.  Buffer information,\nwhether or not it has reached the end of the underlying data source,\netc., are all tracked on this object.\n\nYou are strongly encouraged not to modify this in any way, but it is\noften useful to read from.\n\n## Class: Writable\n\nA base class for creating Writable streams.  Similar to Readable, you\ncan create child classes by overriding the asynchronous\n`_write(chunk,cb)` method, and it will take care of buffering,\nbackpressure, and so on.\n\n### new Writable(options)\n\n* `options` {Object}\n  * `highWaterMark` {Number} The number of bytes to store up before it\n    starts returning `false` from write() calls.  Default = `16 * 1024`\n  * `lowWaterMark` {Number} The number of bytes that the buffer must\n    get down to before it emits `drain`.  Default = `1024`\n\nMake sure to call the `Writable` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### writable.write(chunk, [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String} An encoding argument to turn the string chunk\n  into a buffer.  Only relevant if `chunk` is a string.\n  Default = `'utf8'`.\n* Returns `false` if you should not write until the next `drain`\n  event, or some other value otherwise.\n\nThe basic write function.\n\n### writable.\\_write(chunk, callback)\n\n* `chunk` {Buffer}\n* `callback` {Function}\n  * `error` {Error | null} Call with an error object as the first\n    argument to indicate that the write() failed for unfixable\n    reasons.\n\n**Note: This function is not implemented in the Writable base class.**\nRather, it is up to you to implement `_write` in your extension\nclasses.\n\n`_write` should do whatever has to be done in this specific Writable\nclass, to handle the bytes being written.  Write to a file, send along\na socket, encrypt as an mp3, whatever needs to be done.  Do your I/O\nasynchronously, and call the callback when it's complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### writable.end([chunk], [encoding])\n\n* `chunk` {Buffer | String}\n* `encoding` {String}\n\nIf a chunk (and, optionally, an encoding) are provided, then that\nchunk is first passed to `this.write(chunk, encoding)`.\n\nThis method is a way to signal to the writable stream that you will\nnot be writing any more data.  It should be called exactly once for\nevery writable stream.\n\nCalling `write()` *after* calling `end()` will trigger an error.\n\n### writable.on('pipe', source)\n\nEmitted when calling `source.pipe(writable)`.  See above for the\ndescription of the `readable.pipe()` method.\n\n### writable.on('unpipe', source)\n\nEmitted when calling `source.unpipe(writable)`.  See above for the\ndescription of the `readable.unpipe()` method.\n\n### writable.on('drain')\n\nIf a call to `writable.write()` returns false, then at some point in\nthe future, this event will tell you to start writing again.\n\n### writable.on('finish')\n\nWhen the stream has been ended, and all the data in its internal\nbuffer has been consumed, then it emits a `finish` event to let you\nknow that it's completely done.\n\nThis is particularly handy if you want to know when it is safe to shut\ndown a socket or close a file descriptor.  At this time, the writable\nstream may be safely disposed.  Its mission in life has been\naccomplished.\n\n## Class: Duplex\n\nA base class for Duplex streams (ie, streams that are both readable\nand writable).\n\nSince JS doesn't have multiple prototypal inheritance, this class\nprototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n,cb)` method as well as the lowlevel `_write(chunk,cb)`\nmethod on extension duplex classes.\n\nFor cases where the written data is transformed into the output, it\nmay be simpler to use the `Transform` class instead.\n\n### new Duplex(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Duplex` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\nIf `options.allowHalfOpen` is set to the value `false`, then the\nstream will automatically end the readable side when the writable\nside ends, and vice versa.\n\n### duplex.allowHalfOpen\n\n* {Boolean} Default = `true`\n\nSet this flag to either `true` or `false` to determine whether or not\nto automatically close the writable side when the readable side ends,\nand vice versa.\n\n\n## Class: Transform\n\nA duplex (ie, both readable and writable) stream that is designed to\nmake it easy to implement transform operations such as encryption,\ndecryption, compression, and so on.\n\nTransform streams are `instanceof` Readable, but they have all of the\nmethods and properties of both Readable and Writable streams.  See\nabove for the list of events and methods that Transform inherits from\nWritable and Readable.\n\nOverride the `_transform(chunk, outputFunction, callback)` method in\nyour implementation classes to take advantage of it.\n\n### new Transform(options)\n\n* `options` {Object}  Passed to both the Writable and Readable\n  constructors.\n\nMake sure to call the `Transform` constructor in your extension\nclasses, or else the stream will not be properly initialized.\n\n### transform.\\_transform(chunk, outputFn, callback)\n\n* `chunk` {Buffer} The chunk to be transformed.\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_transform` in your extension\nclasses.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that this may mean that you call the `outputFn` zero\nor more times, depending on how much data you want to output as a\nresult of this chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(outputFn, callback)\n\n* `outputFn` {Function} Call this function with any output data to be\n  passed to the readable interface.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\n**Note: This function is not implemented in the Transform base class.**\nRather, it is up to you to implement `_flush` in your extension\nclasses optionally, if it applies to your use case.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `outputFn` zero or more times, as\nappropriate, and call `callback` when the flush operation is complete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n## Class: PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n","readmeFilename":"README.md","_id":"readable-stream@0.3.1","dist":{"shasum":"82476ce7bbc0ae58e1d5e11f17df86ba6d76c23f","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-0.3.1.tgz"},"_from":".","_npmVersion":"1.2.11","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.0":{"name":"readable-stream","version":"1.0.0","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","_id":"readable-stream@1.0.0","dist":{"shasum":"805b14feb790400d17f314e337d12affcc3549bc","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.0.0.tgz"},"_from":".","_npmVersion":"1.2.14","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.1":{"name":"readable-stream","version":"1.0.1","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","_id":"readable-stream@1.0.1","dist":{"shasum":"04f99de4c0697c86ab65679330b0c9d167b2b9b3","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.0.1.tgz"},"_from":".","_npmVersion":"1.2.14","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.2":{"name":"readable-stream","version":"1.0.2","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","_id":"readable-stream@1.0.2","dist":{"shasum":"213ce36864fc1f0d4e98e03b9eb92c64042299d4","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.0.2.tgz"},"_from":".","_npmVersion":"1.2.14","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.15":{"name":"readable-stream","version":"1.0.15","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/readable-stream/issues"},"_id":"readable-stream@1.0.15","dist":{"shasum":"a2c160237235951da985a1572d0a3af585e4be95","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.0.15.tgz"},"_from":".","_npmVersion":"1.3.7","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.17":{"name":"readable-stream","version":"1.0.17","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/readable-stream/issues"},"_id":"readable-stream@1.0.17","dist":{"shasum":"cbc295fdf394dfa1225d225d02e6b6d0f409fd4b","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.0.17.tgz"},"_from":".","_npmVersion":"1.3.9","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.1.7":{"name":"readable-stream","version":"1.1.7","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{"core-util-is":"~1.0.0","debuglog":"0.0.2"},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"MIT","optionalDependencies":{"debuglog":"0.0.2"},"readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/readable-stream/issues"},"_id":"readable-stream@1.1.7","dist":{"shasum":"9fac85f615c91d8123d6797a37bb6492f3400d34","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.1.7.tgz"},"_from":".","_npmVersion":"1.3.9","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.1.8":{"name":"readable-stream","version":"1.1.8","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{"core-util-is":"~1.0.0","debuglog":"0.0.2"},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"MIT","optionalDependencies":{"debuglog":"0.0.2"},"readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/readable-stream/issues"},"_id":"readable-stream@1.1.8","dist":{"shasum":"28d42847e0feedfd2013931f37fb326fc4e25b7e","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.1.8.tgz"},"_from":".","_npmVersion":"1.3.9","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.1.9":{"name":"readable-stream","version":"1.1.9","description":"An exploration of a new kind of readable streams for Node.js","main":"readable.js","dependencies":{"core-util-is":"~1.0.0","debuglog":"0.0.2"},"devDependencies":{"tap":"~0.2.6"},"scripts":{"test":"tap test/simple/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"keywords":["readable","stream","pipe"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"MIT","optionalDependencies":{"debuglog":"0.0.2"},"readme":"# readable-stream\n\nA new class of streams for Node.js\n\nThis module provides the new Stream base classes introduced in Node\nv0.10, for use in Node v0.8.  You can use it to have programs that\nhave to work with node v0.8, while being forward-compatible for v0.10\nand beyond.  When you drop support for v0.8, you can remove this\nmodule, and only use the native streams.\n\nThis is almost exactly the same codebase as appears in Node v0.10.\nHowever:\n\n1. The exported object is actually the Readable class.  Decorating the\n   native `stream` module would be global pollution.\n2. In v0.10, you can safely use `base64` as an argument to\n   `setEncoding` in Readable streams.  However, in v0.8, the\n   StringDecoder class has no `end()` method, which is problematic for\n   Base64.  So, don't use that, because it'll break and be weird.\n\nOther than that, the API is the same as `require('stream')` in v0.10,\nso the API docs are reproduced below.\n\n----------\n\n    Stability: 2 - Unstable\n\nA stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n## Compatibility\n\nIn earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"old mode\" when a `'data'` event handler is added, or when\nthe `pause()` or `resume()` methods are called.  The effect is that,\neven if you are not using the new `read()` method and `'readable'`\nevent, you no longer have to worry about losing `'data'` chunks.\n\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n\nFor example, consider the following code:\n\n```javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);\n```\n\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n\n```javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n```\n\nIn addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n\n## Class: stream.Readable\n\n<!--type=class-->\n\nA `Readable Stream` has the following methods, members, and events.\n\nNote that `stream.Readable` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nmethod. (See below.)\n\n### new stream.Readable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default=16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n\n\nIn classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### readable.\\_read(size)\n\n* `size` {Number} Number of bytes to read asynchronously\n\nNote: **This function should NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\nAll Readable stream implementations must provide a `_read` method\nto fetch data from the underlying resource.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling `stream.push(chunk)`.\n\n### readable.push(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable subclasses.**  The `_read()` function will not\nbe called again until at least one `push(chunk)` call is made.  If no\ndata is available, then you MAY call `push('')` (an empty string) to\nallow a future `_read` call, without adding any data to the queue.\n\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata.\n\nIn some cases, you may be wrapping a lower-level source which has some\nsort of pause/resume mechanism, and a data callback.  In those cases,\nyou could wrap the low-level source object by doing something like\nthis:\n\n```javascript\n// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nvar stream = new Readable();\n\nsource.ondata = function(chunk) {\n  // if push() returns false, then we need to stop reading from source\n  if (!stream.push(chunk))\n    source.readStop();\n};\n\nsource.onend = function() {\n  stream.push(null);\n};\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nstream._read = function(n) {\n  source.readStart();\n};\n```\n\n### readable.unshift(chunk)\n\n* `chunk` {Buffer | null | String} Chunk of data to unshift onto the read queue\n* return {Boolean} Whether or not more pushes should be performed\n\nThis is the corollary of `readable.push(chunk)`.  Rather than putting\nthe data at the *end* of the read queue, it puts it at the *front* of\nthe read queue.\n\nThis is useful in certain use-cases where a stream is being consumed\nby a parser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source.\n\n```javascript\n// A parser for a simple data protocol.\n// The \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// Note: This can be done more simply as a Transform stream.  See below.\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Readable.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\nvar parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n### readable.wrap(stream)\n\n* `stream` {Stream} An \"old style\" readable stream\n\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a Readable stream that uses the old stream\nas its data source.\n\nFor example:\n\n```javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});\n```\n\n### Event: 'readable'\n\nWhen there is data ready to be consumed, this event will fire.\n\nWhen this event emits, call the `read()` method to consume the data.\n\n### Event: 'end'\n\nEmitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more `'data'` events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n### Event: 'data'\n\nThe `'data'` event emits either a `Buffer` (by default) or a string if\n`setEncoding()` was used.\n\nNote that adding a `'data'` event listener will switch the Readable\nstream into \"old mode\", where data is emitted as soon as it is\navailable, rather than waiting for you to call `read()` to consume it.\n\n### Event: 'error'\n\nEmitted if there was an error receiving data.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### readable.setEncoding(encoding)\n\nMakes the `'data'` event emit a string instead of a `Buffer`. `encoding`\ncan be `'utf8'`, `'utf16le'` (`'ucs2'`), `'ascii'`, or `'hex'`.\n\nThe encoding can also be set by specifying an `encoding` field to the\nconstructor.\n\n### readable.read([size])\n\n* `size` {Number | null} Optional number of bytes to read.\n* Return: {Buffer | String | null}\n\nNote: **This function SHOULD be called by Readable stream users.**\n\nCall this method to consume data once the `'readable'` event is\nemitted.\n\nThe `size` argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\nIf there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the `size` argument, then `null` is returned, and\na future `'readable'` event will be emitted when more is available.\n\nCalling `stream.read(0)` will always return `null`, and will trigger a\nrefresh of the internal buffer, but otherwise be a no-op.\n\n### readable.pipe(destination, [options])\n\n* `destination` {Writable Stream}\n* `options` {Object} Optional\n  * `end` {Boolean} Default=true\n\nConnects this readable stream to `destination` WriteStream. Incoming\ndata on this stream gets written to `destination`.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\nThis function returns the `destination` stream.\n\nFor example, emulating the Unix `cat` command:\n\n    process.stdin.pipe(process.stdout);\n\nBy default `end()` is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n\n    reader.pipe(writer, { end: false });\n    reader.on(\"end\", function() {\n      writer.end(\"Goodbye\\n\");\n    });\n\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n\n### readable.unpipe([destination])\n\n* `destination` {Writable Stream} Optional\n\nUndo a previously established `pipe()`.  If no destination is\nprovided, then all previously established pipes are removed.\n\n### readable.pause()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nCeases the flow of data.  No `'data'` events are emitted while the\nstream is in a paused state.\n\n### readable.resume()\n\nSwitches the readable stream into \"old mode\", where data is emitted\nusing a `'data'` event rather than being buffered for consumption via\nthe `read()` method.\n\nResumes the incoming `'data'` events after a `pause()`.\n\n\n## Class: stream.Writable\n\n<!--type=class-->\n\nA `Writable` Stream has the following methods, members, and events.\n\nNote that `stream.Writable` is an abstract class designed to be\nextended with an underlying implementation of the\n`_write(chunk, encoding, cb)` method. (See below.)\n\n### new stream.Writable([options])\n\n* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when `write()` starts\n    returning false. Default=16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to `_write()`.  Default=true\n\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### writable.\\_write(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nAll Writable stream implementations must provide a `_write` method to\nsend data to the underlying resource.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n\n### writable.write(chunk, [encoding], [callback])\n\n* `chunk` {Buffer | String} Data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when this chunk is\n  successfully written.\n* Returns {Boolean}\n\nWrites `chunk` to the stream.  Returns `true` if the data has been\nflushed to the underlying resource.  Returns `false` to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n`'drain'` event will indicate when the buffer is empty again.\n\nThe specifics of when `write()` will return false, is determined by\nthe `highWaterMark` option provided to the constructor.\n\n### writable.end([chunk], [encoding], [callback])\n\n* `chunk` {Buffer | String} Optional final data to be written\n* `encoding` {String} Optional.  If `chunk` is a string, then encoding\n  defaults to `'utf8'`\n* `callback` {Function} Optional.  Called when the final chunk is\n  successfully written.\n\nCall this method to signal the end of the data being written to the\nstream.\n\n### Event: 'drain'\n\nEmitted when the stream's write queue empties and it's safe to write\nwithout buffering again. Listen for it when `stream.write()` returns\n`false`.\n\n### Event: 'close'\n\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n### Event: 'finish'\n\nWhen `end()` is called and there are no more chunks to write, this\nevent is emitted.\n\n### Event: 'pipe'\n\n* `source` {Readable Stream}\n\nEmitted when the stream is passed to a readable stream's pipe method.\n\n### Event 'unpipe'\n\n* `source` {Readable Stream}\n\nEmitted when a previously established `pipe()` is removed using the\nsource Readable stream's `unpipe()` method.\n\n## Class: stream.Duplex\n\n<!--type=class-->\n\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\nNote that `stream.Duplex` is an abstract class designed to be\nextended with an underlying implementation of the `_read(size)`\nand `_write(chunk, encoding, callback)` methods as you would with a Readable or\nWritable stream class.\n\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel `_write(chunk, encoding, cb)` method\non extension duplex classes.\n\n### new stream.Duplex(options)\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default=true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.\n\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n## Class: stream.Transform\n\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\nRather than implement the `_read()` and `_write()` methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n\n### new stream.Transform([options])\n\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n### transform.\\_transform(chunk, encoding, callback)\n\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### transform.\\_flush(callback)\n\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n\n### Example: `SimpleProtocol` parser\n\nThe example above of a simple protocol parser can be implemented much\nmore simply by using the higher level `Transform` stream class.\n\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n\n```javascript\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype = Object.create(\n  Transform.prototype, { constructor: { value: SimpleProtocol }});\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(b);\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(b);\n  }\n  done();\n};\n\nvar parser = new SimpleProtocol();\nsource.pipe(parser)\n\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.\n```\n\n\n## Class: stream.PassThrough\n\nThis is a trivial implementation of a `Transform` stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n[EventEmitter]: events.html#events_class_events_eventemitter\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/readable-stream/issues"},"_id":"readable-stream@1.1.9","dist":{"shasum":"d87130fbf8f9ee9c3b4058b3c58a3e30db2fcfdd","tarball":"http://registry.npmjs.org/readable-stream/-/readable-stream-1.1.9.tgz"},"_from":".","_npmVersion":"1.3.11","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}}},"readme":"# readable-stream\n\n    Stability: 1 - Experimental\n\nAn exploration of a new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\n## Usage\n\n```javascript\nvar Readable = require('readable-stream');\nvar r = new Readable();\n\nr.read = function(n) {\n  // your magic goes here.\n  // return n bytes, or null if there is nothing to be read.\n  // if you return null, then you MUST emit 'readable' at some\n  // point in the future if there are bytes available, or 'end'\n  // if you are not going to have any more data.\n  //\n  // You MUST NOT emit either 'end' or 'readable' before\n  // returning from this function, but you MAY emit 'end' or\n  // 'readable' in process.nextTick().\n};\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n```\n\n## Justification\n\nWritable streams in node are very straightforward to use and extend.\nThe `write` method either returns `true` if the bytes could be\ncompletely handled and another `write` should be performed, or `false`\nif you would like the user to back off a bit, in which case a `drain`\nevent at some point in the future will let them continue writing.  The\n`end()` method lets the user indicate that no more bytes will be\nwritten.  That's pretty much the entire required interface for\nwriting.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, and so on.  This is all\nrather brittle and easy to get wrong for all but the most trivial use\ncases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.\n\n### Compatibility\n\nIt's not particularly difficult to wrap older-style streams in this\nnew interface, or to wrap this type of stream in the older-style\ninterface.\n\nThe `Readable` class takes an argument which is an old-style stream\nwith `data` events and `pause()` and `resume()` methods, and uses that\nas the data source.  For example:\n\n```javascript\nvar r = new Readable(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n```\n\nThe `Readable` class will also automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n});\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n","maintainers":[{"name":"isaacs","email":"i@izs.me"},{"name":"tootallnate","email":"nathan@tootallnate.net"}],"time":{"0.0.1":"2012-07-27T04:46:58.911Z","0.0.2":"2012-09-10T18:32:22.628Z","0.0.3":"2012-10-15T18:50:21.287Z","0.0.4":"2012-12-03T05:37:50.997Z","0.1.0":"2012-12-14T00:10:04.841Z","0.2.0":"2013-01-11T23:31:27.220Z","0.3.0":"2013-02-14T22:59:03.141Z","0.3.1":"2013-02-20T19:18:23.014Z","1.0.0":"2013-03-09T19:16:19.726Z","1.0.1":"2013-03-11T02:20:24.538Z","1.0.2":"2013-03-11T16:31:26.752Z","1.0.15":"2013-08-02T22:03:15.036Z","1.0.17":"2013-08-26T22:38:58.256Z","1.1.7":"2013-08-26T23:14:28.483Z","1.1.8":"2013-08-30T20:01:01.457Z","1.1.9":"2013-09-13T15:00:47.024Z"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git://github.com/isaacs/readable-stream"},"users":{"fgribreau":true,"aredridel":true,"isao":true},"_attachments":{"readable-stream-1.1.9.tgz":{"content_type":"application/octet-stream","revpos":42,"digest":"md5-9sI4GPjT2xzLgxmKt36TUA==","length":59651,"stub":true},"readable-stream-1.1.8.tgz":{"content_type":"application/octet-stream","revpos":40,"digest":"md5-dyxn1VLnQ6NsBCVC5jH2qQ==","length":59631,"stub":true},"readable-stream-1.1.7.tgz":{"content_type":"application/octet-stream","revpos":38,"digest":"md5-ht/GI/zLXBG/Xz8SHK+hNQ==","length":56857,"stub":true},"readable-stream-1.0.17.tgz":{"content_type":"application/octet-stream","revpos":36,"digest":"md5-ZfZj+MWO8BwQv7ZYsUfN6Q==","length":47440,"stub":true},"readable-stream-1.0.15.tgz":{"content_type":"application/octet-stream","revpos":34,"digest":"md5-vvqXNqIIcPIEKt4eFiSVww==","length":47315,"stub":true},"readable-stream-1.0.2.tgz":{"content_type":"application/octet-stream","revpos":31,"digest":"md5-HV85vcvdJHqU2JM3nlSvXg==","length":46233,"stub":true},"readable-stream-1.0.1.tgz":{"content_type":"application/octet-stream","revpos":29,"digest":"md5-AnJnhCRCBpyZWhs17wFz4A==","length":46235,"stub":true},"readable-stream-1.0.0.tgz":{"content_type":"application/octet-stream","revpos":27,"digest":"md5-8S9cnBfVS/dqA3CpIvg6mA==","length":45918,"stub":true},"readable-stream-0.3.1.tgz":{"content_type":"application/octet-stream","revpos":26,"digest":"md5-eMqstQ0dssWsvD6ti4E3dw==","length":39335,"stub":true},"readable-stream-0.3.0.tgz":{"content_type":"application/octet-stream","revpos":24,"digest":"md5-+HtNIKvKLTcJLgHCvYKmXg==","length":40600,"stub":true},"readable-stream-0.2.0.tgz":{"content_type":"application/octet-stream","revpos":21,"digest":"md5-S5975iA7l0embcE0pL7eUw==","length":40911,"stub":true},"readable-stream-0.1.0.tgz":{"content_type":"application/octet-stream","revpos":15,"digest":"md5-eA+HSYwrApPZg2xb2ZLIEA==","length":38740,"stub":true},"readable-stream-0.0.4.tgz":{"content_type":"application/octet-stream","revpos":13,"digest":"md5-iBCQbKFOxztpCg6yNjRl6w==","length":44466,"stub":true},"readable-stream-0.0.3.tgz":{"content_type":"application/octet-stream","revpos":10,"digest":"md5-Eyif+OTJFnHxpJgddUPXEA==","length":22395,"stub":true},"readable-stream-0.0.2.tgz":{"content_type":"application/octet-stream","revpos":7,"digest":"md5-XJMCAHLk4OxZl/C4m8Dv3w==","length":9167,"stub":true},"readable-stream-0.0.1.tgz":{"content_type":"application/octet-stream","revpos":3,"digest":"md5-Yg41xTjLlgxPqMd6nIDAfg==","length":6861,"stub":true}},"_etag":"\"18ANW2RMNEN75EBUE4D14M70T\""}